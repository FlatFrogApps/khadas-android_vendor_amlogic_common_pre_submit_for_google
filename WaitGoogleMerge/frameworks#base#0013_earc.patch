From ca02ad15202be4ad842ff53926c4c68554081dc4 Mon Sep 17 00:00:00 2001
From: "an.xi" <an.xi@amlogic.com>
Date: Tue, 14 Dec 2021 20:40:08 +0800
Subject: [PATCH] cec: start arc actively when earc is off [1/1]

PD#SWPL-67986

Problem:
The earc/arc audio system device may not switch
to arc when turn off earc.

Solution:
Start arc actively when earc is off.

Verify:
tv

Change-Id: I58a34bc893da3d529255d2f6d676faa033d3b265
Signed-off-by: an.xi <an.xi@amlogic.com>
---
 .../server/hdmi/HdmiCecLocalDevice.java       |  3 ++
 .../server/hdmi/HdmiCecLocalDeviceTv.java     | 22 ++++++--
 .../server/hdmi/HdmiControlService.java       | 53 +++++++++++++++++--
 .../hdmi/RequestArcTerminationAction.java     | 39 ++++++++++++++
 4 files changed, 109 insertions(+), 8 deletions(-)
 mode change 100755 => 100644 services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java

diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
index b1e22f162f88..9902afa70666 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
@@ -1148,6 +1148,9 @@ abstract class HdmiCecLocalDevice {
         HdmiLogger.info("onEarcStateChanged current:" + mEarcOn + " new:" + earcOn);
     }
 
+    protected void onEarcSettingChanged(boolean isEarcOn) {
+    }
+
     /** Dump internal status of HdmiCecLocalDevice object. */
     protected void dump(final IndentingPrintWriter pw) {
         pw.println("mDeviceType: " + mDeviceType);
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
old mode 100755
new mode 100644
index c1227dcb24c8..69840b643d0b
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
@@ -227,6 +227,11 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
 
     protected void onEarcStateChanged(boolean earcOn) {
         super.onEarcStateChanged(earcOn);
+        if (mService.isSystemAudioActivated()) {
+            // Give a shot for arc action when earc is off.
+            HdmiLogger.debug("Going to start arc action when earc is changed");
+            startArcAction(!earcOn);
+        }
         if (mEarcOn == earcOn) {
             return;
         }
@@ -235,6 +240,15 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         updateEarcState(earcOn);
     }
 
+    public void onEarcSettingChanged(boolean on) {
+        HdmiLogger.debug("TV onEarcSettingChanged when arc is " + mArcEstablished);
+        if (on && mArcEstablished) {
+            addAndStartAction(new RequestArcTerminationAction(this, Constants.ADDR_AUDIO_SYSTEM, on));
+        } else if (!on && !mArcEstablished) {
+            startArcAction(true);
+        }
+    }
+
     private void updateEarcState(boolean earcOn) {
         HdmiLogger.info("updateEarcState:" + earcOn);
         updateAudioManagerForSystemAudio(earcOn);
@@ -896,7 +910,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     void changeSystemAudioMode(boolean enabled, IHdmiControlCallback callback) {
         assertRunOnServiceThread();
         if (!mService.isControlEnabled()) {
+            HdmiLogger.debug("changeSystemAudioMode false while cec is disabled!");
             setSystemAudioMode(false);
+            mService.sendCecCommand(HdmiCecMessageBuilder.buildSystemAudioModeRequest(
+                mAddress, Constants.ADDR_AUDIO_SYSTEM, 0, false));
             invokeCallback(callback, HdmiControlManager.RESULT_INCORRECT_MODE);
             return;
         }
@@ -1082,10 +1099,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     @ServiceThreadOnly
     void startArcAction(boolean enabled) {
         assertRunOnServiceThread();
-        HdmiLogger.info("startArcAction[old:%b new:%b]", mArcEstablished, enabled);
-        if (enabled == mArcEstablished) {
-            return;
-        }
+        HdmiLogger.info("startArcAction [old:%b new:%b]", mArcEstablished, enabled);
 
         HdmiDeviceInfo info = getAvrDeviceInfo();
         if (!isConnectedToArcDevice(info)) {
diff --git a/services/core/java/com/android/server/hdmi/HdmiControlService.java b/services/core/java/com/android/server/hdmi/HdmiControlService.java
index f472280b3809..046bbb173970 100644
--- a/services/core/java/com/android/server/hdmi/HdmiControlService.java
+++ b/services/core/java/com/android/server/hdmi/HdmiControlService.java
@@ -360,6 +360,8 @@ public class HdmiControlService extends SystemService {
 
     private HdmiCecMessageValidator mMessageValidator;
 
+    private boolean mBootComplete;
+
     @ServiceThreadOnly
     private int mPowerStatus = HdmiControlManager.POWER_STATUS_UNKNOWN;
 
@@ -570,10 +572,13 @@ public class HdmiControlService extends SystemService {
     }
 
     private void bootCompleted() {
+        HdmiLogger.info("bootCompleted");
         // on boot, if device is interactive, set HDMI CEC state as powered on as well
         if (mPowerManager.isInteractive() && isPowerStandbyOrTransient()) {
             onWakeUp();
         }
+        mBootComplete = true;
+        onEarcStateChanged(isEarcOn());
     }
 
     /**
@@ -693,7 +698,8 @@ public class HdmiControlService extends SystemService {
                 Global.MHL_INPUT_SWITCHING_ENABLED,
                 Global.MHL_POWER_CHARGE_ENABLED,
                 Global.HDMI_CEC_SWITCH_ENABLED,
-                Global.DEVICE_NAME
+                Global.DEVICE_NAME,
+                EARC_ENABLE
         };
         for (String s : settings) {
             resolver.registerContentObserver(Global.getUriFor(s), false, mSettingsObserver,
@@ -781,11 +787,21 @@ public class HdmiControlService extends SystemService {
                     String deviceName = readStringSetting(option, Build.MODEL);
                     setDisplayName(deviceName);
                     break;
+                case EARC_ENABLE:
+                    mEarcSettings = enabled;
+                    HdmiLogger.debug("earc settings changed to " + enabled);
+                    onEarcSettingChanged(enabled);
+                    break;
             }
         }
     }
 
     /*********************EARC BEGIN************************************************/
+    public static final String HAL_PARAM_EARCTX_EARC_MODE  = "hal_param_earctx_earc_mode=";
+
+    public static final String EARC_ENABLE = "earc_enable";
+
+    private boolean mEarcSettings;
     private boolean mEarcSupported;
     private EarcObserver mEarcObserver;
 
@@ -797,11 +813,16 @@ public class HdmiControlService extends SystemService {
             deviceType = HdmiDeviceInfo.DEVICE_AUDIO_SYSTEM;
         }
         mEarcSupported = EarcObserver.isEarcSupport();
-        Slog.i(TAG, "initEarcState isEarcSupported " + mEarcSupported);
+        mEarcSettings = readBooleanSetting(EARC_ENABLE, true);
+        Slog.i(TAG, "initEarcState isEarcSupported:" + mEarcSupported
+                    + " settings:" + mEarcSettings);
 
         if (!mEarcSupported) {
             return;
         }
+        if (!mEarcSettings) {
+            setEarcMode(false);
+        }
         mEarcObserver = EarcObserver.ceateEarcObserver(this, deviceType);
     }
 
@@ -811,10 +832,15 @@ public class HdmiControlService extends SystemService {
 
     public boolean isEarcOn() {
         return mEarcSupported
-               && mEarcObserver.isEarcOn();
+               && mEarcObserver.isEarcOn()
+               && mEarcSettings;
     }
 
     public void onEarcStateChanged(final boolean isEarcOn) {
+        if (!mBootComplete) {
+            HdmiLogger.info("onEarcStateChanged abort for not boot completed " + isEarcOn);
+            return;
+        }
         runOnServiceThread(()->{
             if (tv() != null) {
                 tv().onEarcStateChanged(isEarcOn);
@@ -825,6 +851,23 @@ public class HdmiControlService extends SystemService {
 
     }
 
+    public void onEarcSettingChanged(boolean on) {
+        if (!on) {
+            // directly turn off earc.
+            setEarcMode(false);
+        }
+        if (tv() != null) {
+            tv().onEarcSettingChanged(on);
+        } else if (audioSystem() != null) {
+            audioSystem().onEarcSettingChanged(on);
+        }
+    }
+
+    public void setEarcMode(boolean on) {
+        HdmiLogger.info("setEarcMode " + on);
+        getAudioManager().setParameters(HAL_PARAM_EARCTX_EARC_MODE + (on ? 1 : 0));
+    }
+
     /*********************EARC END************************************************/
 
     private static int toInt(boolean enabled) {
@@ -934,7 +977,9 @@ public class HdmiControlService extends SystemService {
                     }
 
                     // Init earc state.
-                    localDevice.onEarcStateChanged(isEarcOn());
+                    if (mBootComplete) {
+                        localDevice.onEarcStateChanged(isEarcOn());
+                    }
 
                     // Address allocation completed for all devices. Notify each device.
                     if (allocatingDevices.size() == ++finished[0]) {
diff --git a/services/core/java/com/android/server/hdmi/RequestArcTerminationAction.java b/services/core/java/com/android/server/hdmi/RequestArcTerminationAction.java
index 3a2af0eb972e..f362a4126892 100644
--- a/services/core/java/com/android/server/hdmi/RequestArcTerminationAction.java
+++ b/services/core/java/com/android/server/hdmi/RequestArcTerminationAction.java
@@ -25,6 +25,7 @@ import android.hardware.tv.cec.V1_0.SendMessageResult;
  */
 final class RequestArcTerminationAction extends RequestArcAction {
     private static final String TAG = "RequestArcTerminationAction";
+    private boolean mEarc;
 
     /**
      * @Constructor
@@ -35,6 +36,12 @@ final class RequestArcTerminationAction extends RequestArcAction {
         super(source, avrAddress);
     }
 
+    RequestArcTerminationAction(HdmiCecLocalDevice source, int avrAddress, boolean earcOn) {
+        super(source, avrAddress);
+        mEarc = earcOn;
+    }
+
+
     @Override
     boolean start() {
         mState = STATE_WATING_FOR_REQUEST_ARC_REQUEST_RESPONSE;
@@ -56,6 +63,38 @@ final class RequestArcTerminationAction extends RequestArcAction {
         return true;
     }
 
+    @Override
+    boolean processCommand(HdmiCecMessage cmd) {
+        if (mState != STATE_WATING_FOR_REQUEST_ARC_REQUEST_RESPONSE
+                || !HdmiUtils.checkCommandSource(cmd, mAvrAddress, TAG)) {
+            return false;
+        }
+        int opcode = cmd.getOpcode();
+        switch (opcode) {
+            // Handles only <Feature Abort> here and, both <Initiate ARC> and <Terminate ARC>
+            // are handled in HdmiControlService itself because both can be
+            // received without <Request ARC Initiation> or <Request ARC Termination>.
+            case Constants.MESSAGE_FEATURE_ABORT:
+                int originalOpcode = cmd.getParams()[0] & 0xFF;
+                if (originalOpcode == Constants.MESSAGE_REQUEST_ARC_TERMINATION) {
+                    disableArcTransmission();
+                    finish();
+                    return true;
+                }
+                break;
+            case Constants.MESSAGE_TERMINATE_ARC:
+                if (mEarc) {
+                    HdmiLogger.info("Terminate arc and then start earc.");
+                    tv().handleTerminateArc(cmd);
+                    tv().mService.setEarcMode(true);
+                    return true;
+                }
+                break;
+        }
+        return false;
+    }
+
+
     @Override
     final void handleTimerEvent(int state) {
         if (mState != state || state != STATE_WATING_FOR_REQUEST_ARC_REQUEST_RESPONSE) {
-- 
2.25.1

