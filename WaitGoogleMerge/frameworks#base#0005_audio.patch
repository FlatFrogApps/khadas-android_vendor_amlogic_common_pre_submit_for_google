From ff2a8574eae71940128a63ae5d719508f9a8fdf2 Mon Sep 17 00:00:00 2001
From: "an.xi" <an.xi@amlogic.com>
Date: Tue, 22 Dec 2020 02:52:32 -0500
Subject: [PATCH] cec: add volume keyevent paththrough for NTS [1/2]

PD#SWPL-39241

Problem:
NTS volume paththrough feature. When user uses playback's
remote to control volume in ddp5.0 format, playback should
transfer the volume keyevents to tv.

Solution:
Transfer the volume keyevents to TV when the playback is
using dpp5.0 audio format.

Verify:
newton

Change-Id: I3e3f53b7c64a17fb204ffba9d3189b2ae3f74b6f
Signed-off-by: an.xi <an.xi@amlogic.com>
---
 core/res/res/values-zh-rCN/strings.xml        |   1 +
 core/res/res/values/strings.xml               |   2 +
 core/res/res/values/symbols.xml               |   1 +
 .../android/server/audio/AudioService.java    | 244 +++++++++++++-----
 .../android/server/hdmi/HdmiCecMessage.java   |   5 +
 5 files changed, 187 insertions(+), 66 deletions(-)

diff --git a/core/res/res/values-zh-rCN/strings.xml b/core/res/res/values-zh-rCN/strings.xml
index a645cd7db90a..cadcd21b7bf6 100644
--- a/core/res/res/values-zh-rCN/strings.xml
+++ b/core/res/res/values-zh-rCN/strings.xml
@@ -1986,6 +1986,7 @@
     <string name="screenshot_edit" msgid="7408934887203689207">"编辑"</string>
     <string name="volume_dialog_ringer_guidance_vibrate" msgid="2055927873175228519">"有来电和通知时会振动"</string>
     <string name="volume_dialog_ringer_guidance_silent" msgid="1011246774949993783">"有来电和通知时会静音"</string>
+    <string name="volume_passthrough_hint">如果音量无法调节，请换用TV遥控器</string>
     <string name="notification_channel_system_changes" msgid="2462010596920209678">"系统变更"</string>
     <string name="notification_channel_do_not_disturb" msgid="7832584281883687653">"勿扰"</string>
     <string name="zen_upgrade_notification_visd_title" msgid="2001148984371968620">"新功能：勿扰模式目前可隐藏通知"</string>
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index d6ee28b93f92..bf172ddd1550 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -5304,6 +5304,8 @@
     <string name="volume_dialog_ringer_guidance_vibrate">Calls and notifications will vibrate</string>
     <string name="volume_dialog_ringer_guidance_silent">Calls and notifications will be muted</string>
 
+    <string name="volume_passthrough_hint">If the volume can not be adjusted, please switch to the TV remote control</string>
+
     <!-- Title for the notification channel notifying user of settings system changes. [CHAR LIMIT=NONE] -->
     <string name="notification_channel_system_changes">System changes</string>
     <!-- Title for the notification channel notifying user of do not disturb system changes (i.e. Do Not Disturb has changed). [CHAR LIMIT=NONE] -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 06f357e79a62..ea359c495f92 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -1038,6 +1038,7 @@
   <java-symbol type="string" name="volume_icon_description_ringer" />
   <java-symbol type="string" name="volume_dialog_ringer_guidance_vibrate" />
   <java-symbol type="string" name="volume_dialog_ringer_guidance_silent" />
+  <java-symbol type="string" name="volume_passthrough_hint" />
   <java-symbol type="string" name="wait" />
   <java-symbol type="string" name="webpage_unresponsive" />
   <java-symbol type="string" name="whichApplication" />
diff --git a/services/core/java/com/android/server/audio/AudioService.java b/services/core/java/com/android/server/audio/AudioService.java
index 7bb3e36d959e..1d750439f938 100755
--- a/services/core/java/com/android/server/audio/AudioService.java
+++ b/services/core/java/com/android/server/audio/AudioService.java
@@ -143,6 +143,7 @@ import android.widget.Toast;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.R;
 import com.android.internal.util.DumpUtils;
 import com.android.internal.util.Preconditions;
 import com.android.server.EventLogTags;
@@ -153,6 +154,7 @@ import com.android.server.audio.AudioServiceEvents.VolumeEvent;
 import com.android.server.pm.UserManagerService;
 import com.android.server.wm.ActivityTaskManagerInternal;
 
+import java.io.File;
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -188,7 +190,7 @@ public class AudioService extends IAudioService.Stub
         implements AccessibilityManager.TouchExplorationStateChangeListener,
             AccessibilityManager.AccessibilityServicesStateChangeListener {
 
-    private static final String TAG = "AS.AudioService";
+    private static final String TAG = "AudioService";
 
     private final AudioSystemAdapter mAudioSystem;
     private final SystemServerAdapter mSystemServer;
@@ -200,7 +202,7 @@ public class AudioService extends IAudioService.Stub
     protected static final boolean DEBUG_AP = false;
 
     /** Debug volumes */
-    protected static final boolean DEBUG_VOL = false;
+    protected static final boolean DEBUG_VOL = Log.isLoggable(TAG, Log.DEBUG);
 
     /** debug calls to devices APIs */
     protected static final boolean DEBUG_DEVICES = false;
@@ -820,6 +822,10 @@ public class AudioService extends IAudioService.Stub
 
         mRecordMonitor = new RecordingActivityMonitor(mContext);
 
+        // Volume passhrough feature could be enabled for all projects.
+        mVolumePassthroughEnabled = SystemProperties.getBoolean(PROP_VOLUME_PASSTHROUGH, true);
+        mSupportDolbyMS12 = new File(PATH_LIB_DOLBY_SM12).exists();
+
         // must be called before readPersistedSettings() which needs a valid mStreamVolumeAlias[]
         // array initialized by updateStreamVolumeAlias()
         updateStreamVolumeAlias(false /*updateVolumes*/, TAG);
@@ -1348,6 +1354,7 @@ public class AudioService extends IAudioService.Stub
 
     private void onCheckVolumeCecOnHdmiConnection(
             @AudioService.ConnectionState int state, String caller) {
+        Slog.d(TAG, "onCheckVolumeCecOnHdmiConnection " + state);
         if (state == AudioService.CONNECTION_STATE_CONNECTED) {
             // DEVICE_OUT_HDMI is now connected
             if (mSafeMediaVolumeDevices.contains(AudioSystem.DEVICE_OUT_HDMI)) {
@@ -1364,18 +1371,16 @@ public class AudioService extends IAudioService.Stub
                 checkAddAllFixedVolumeDevices(AudioSystem.DEVICE_OUT_HDMI, caller);
                 synchronized (mHdmiClientLock) {
                     if (mHdmiManager != null && mHdmiPlaybackClient != null) {
-                        updateHdmiCecSinkLocked(mHdmiCecSink | false);
+                        mHdmiPlaybackClient.queryDisplayStatus(mHdmiDisplayStatusCallback);
                     }
                 }
             }
             sendEnabledSurroundFormats(mContentResolver, true);
         } else {
             // DEVICE_OUT_HDMI disconnected
-            if (isPlatformTelevision()) {
-                synchronized (mHdmiClientLock) {
-                    if (mHdmiManager != null) {
-                        updateHdmiCecSinkLocked(mHdmiCecSink | false);
-                    }
+            synchronized (mHdmiClientLock) {
+                if (mHdmiManager != null) {
+                    updateHdmiCecSinkLocked(false);
                 }
             }
         }
@@ -2233,11 +2238,14 @@ public class AudioService extends IAudioService.Stub
             adjustVolume = false;
         }
         int oldIndex = mStreamStates[streamType].getIndex(device);
-
+        synchronized (mHdmiClientLock) {
+            if (passthroughToTv(streamType, direction, oldIndex, oldIndex, keyEventMode)) {
+                return;
+            }
+        }
         if (adjustVolume
                 && (direction != AudioManager.ADJUST_SAME) && (keyEventMode != VOL_ADJUST_END)) {
             mAudioHandler.removeMessages(MSG_UNMUTE_STREAM);
-
             if (isMuteAdjust) {
                 boolean state;
                 if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {
@@ -2321,61 +2329,16 @@ public class AudioService extends IAudioService.Stub
         }
 
         final int newIndex = mStreamStates[streamType].getIndex(device);
-
         if (adjustVolume) {
             synchronized (mHdmiClientLock) {
-                if (mHdmiManager != null) {
-                    // mHdmiCecSink true => mHdmiPlaybackClient != null
-                    if (mHdmiCecSink
-                            && mHdmiCecVolumeControlEnabled
-                            && streamTypeAlias == AudioSystem.STREAM_MUSIC
-                            // vol change on a full volume device
-                            && isFullVolumeDevice(device)) {
-                        int keyCode = KeyEvent.KEYCODE_UNKNOWN;
-                        switch (direction) {
-                            case AudioManager.ADJUST_RAISE:
-                                keyCode = KeyEvent.KEYCODE_VOLUME_UP;
-                                break;
-                            case AudioManager.ADJUST_LOWER:
-                                keyCode = KeyEvent.KEYCODE_VOLUME_DOWN;
-                                break;
-                            case AudioManager.ADJUST_TOGGLE_MUTE:
-                                keyCode = KeyEvent.KEYCODE_VOLUME_MUTE;
-                                break;
-                            default:
-                                break;
-                        }
-                        if (keyCode != KeyEvent.KEYCODE_UNKNOWN) {
-                            final long ident = Binder.clearCallingIdentity();
-                            try {
-                                final long time = java.lang.System.currentTimeMillis();
-                                switch (keyEventMode) {
-                                    case VOL_ADJUST_NORMAL:
-                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
-                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
-                                        break;
-                                    case VOL_ADJUST_START:
-                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
-                                        break;
-                                    case VOL_ADJUST_END:
-                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
-                                        break;
-                                    default:
-                                        Log.e(TAG, "Invalid keyEventMode " + keyEventMode);
-                                }
-                            } finally {
-                                Binder.restoreCallingIdentity(ident);
-                            }
-                        }
-                    }
-
-                    if (streamTypeAlias == AudioSystem.STREAM_MUSIC
-                            && (oldIndex != newIndex || isMuteAdjust)) {
-                        maybeSendSystemAudioStatusCommand(isMuteAdjust);
-                    }
+                if (mHdmiManager != null
+                        && streamTypeAlias == AudioSystem.STREAM_MUSIC
+                        && (oldIndex != newIndex || isMuteAdjust)) {
+                    maybeSendSystemAudioStatusCommand(isMuteAdjust);
                 }
             }
         }
+
         sendVolumeUpdate(streamType, oldIndex, newIndex, flags, device);
     }
 
@@ -2851,11 +2814,24 @@ public class AudioService extends IAudioService.Stub
                     && (oldIndex != index)) {
                 maybeSendSystemAudioStatusCommand(false);
             }
+            if (passthroughToTv(streamType, 0, oldIndex, index, VOL_ADJUST_NORMAL)) {
+                return;
+            }
         }
         sendVolumeUpdate(streamType, oldIndex, index, flags, device);
     }
 
-
+    private int getDirection(int newIndex, int oldIndex, int maxIndex, int minIndex) {
+        Slog.d(TAG, "new=" + newIndex + " old=" + oldIndex + " max=" + maxIndex + " min=" + minIndex);
+        int direction = AudioManager.ADJUST_SAME;
+        int offset = newIndex - oldIndex;
+        if (offset > 0 || (offset == 0 && newIndex == maxIndex)) {
+            direction = AudioManager.ADJUST_RAISE;
+        } else if (offset < 0 || (offset == 0 && newIndex == minIndex)) {
+            direction = AudioManager.ADJUST_LOWER;
+        }
+        return direction;
+    }
 
     private int getVolumeGroupIdForAttributes(@NonNull AudioAttributes attributes) {
         Objects.requireNonNull(attributes, "attributes must not be null");
@@ -3011,11 +2987,13 @@ public class AudioService extends IAudioService.Stub
     // UI update and Broadcast Intent
     protected void sendVolumeUpdate(int streamType, int oldIndex, int index, int flags, int device)
     {
+        Slog.d(TAG, "sendVolumeUpdate update volume ui");
         streamType = mStreamVolumeAlias[streamType];
 
         if (streamType == AudioSystem.STREAM_MUSIC) {
             flags = updateFlagsForTvPlatform(flags);
             if (isFullVolumeDevice(device)) {
+                Slog.d(TAG, "sendVolumeUpdate no volume ui");
                 flags &= ~AudioManager.FLAG_SHOW_UI;
             }
         }
@@ -7261,17 +7239,14 @@ public class AudioService extends IAudioService.Stub
 
     @GuardedBy("mHdmiClientLock")
     private void updateHdmiCecSinkLocked(boolean hdmiCecSink) {
+        Log.d(TAG, "updateHdmiCecSinkLocked " + hdmiCecSink);
         mHdmiCecSink = hdmiCecSink;
         if (!hasDeviceVolumeBehavior(AudioSystem.DEVICE_OUT_HDMI)) {
             if (mHdmiCecSink) {
-                if (DEBUG_VOL) {
                     Log.d(TAG, "CEC sink: setting HDMI as full vol device");
-                }
-                addAudioSystemDeviceOutToFullVolumeDevices(AudioSystem.DEVICE_OUT_HDMI);
+                //addAudioSystemDeviceOutToFullVolumeDevices(AudioSystem.DEVICE_OUT_HDMI);
             } else {
-                if (DEBUG_VOL) {
                     Log.d(TAG, "TV, no CEC: setting HDMI as regular vol device");
-                }
                 // Android TV devices without CEC service apply software volume on
                 // HDMI output
                 removeAudioSystemDeviceOutFromFullVolumeDevices(AudioSystem.DEVICE_OUT_HDMI);
@@ -7287,6 +7262,7 @@ public class AudioService extends IAudioService.Stub
         public void onStatusChange(boolean isCecEnabled, boolean isCecAvailable) {
             synchronized (mHdmiClientLock) {
                 if (mHdmiManager == null) return;
+                Slog.d(TAG, "cec status change enabled=" + isCecEnabled + " available=" + isCecAvailable);
                 updateHdmiCecSinkLocked(isCecEnabled ? isCecAvailable : false);
             }
         }
@@ -7302,6 +7278,15 @@ public class AudioService extends IAudioService.Stub
         }
     };
 
+    private class MyDisplayStatusCallback implements HdmiPlaybackClient.DisplayStatusCallback {
+        public void onComplete(int status) {
+            synchronized (mHdmiClientLock) {
+                if (mHdmiManager == null) return;
+                updateHdmiCecSinkLocked(status != HdmiControlManager.POWER_STATUS_UNKNOWN);
+            }
+        }
+    };
+
     private final Object mHdmiClientLock = new Object();
 
     // If HDMI-CEC system audio is supported
@@ -7328,12 +7313,135 @@ public class AudioService extends IAudioService.Stub
     @GuardedBy("mHdmiClientLock")
     private boolean mHdmiCecVolumeControlEnabled;
 
+    // CEC Volume Passthrough feature related
+    private boolean mVolumePassthroughEnabled;
+    private boolean mSupportDolbyMS12;
+    private boolean mInVolumePassthrough;
+    private boolean mShowingPassthroughHint;
+
+    private final Handler mHandler = new Handler();
+
+    private static final String PROP_VOLUME_PASSTHROUGH = "ro.hdmi.volume.passthrough";
+    private static final String PROP_VOLUME_CH_ENABLE = "sys.audio.passthrough";
+    private static final String PROP_PASSTHOURGH_TOAST = "sys.audio.passthrough.toast";
+    private static final String PATH_LIB_DOLBY_SM12 = "/odm/lib/ms12/libdolbyms12.so";
+
+    //==========================================================================================
+    // Volume Passthrough
+    private boolean passthroughToTv(int streamType, int direction, int oldIndex, int newIndex, int keyEventMode) {
+        if (mHdmiManager == null || mHdmiPlaybackClient == null) {
+            // only for box devices
+            return false;
+        }
+        mInVolumePassthrough = SystemProperties.getBoolean(PROP_VOLUME_CH_ENABLE, false);
+        if (mStreamVolumeAlias[streamType] != AudioSystem.STREAM_MUSIC) {
+            Slog.d(TAG, "passthroughToTv not music stream type.");
+            return false;
+        }
+
+        // Not support passthrough feature
+        if (!mVolumePassthroughEnabled || mSupportDolbyMS12) {
+            Slog.d(TAG, "passthroughToTv not support.");
+            return false;
+        }
+
+        // Not in passthrough audio channel
+        if (!mInVolumePassthrough) {
+            Slog.d(TAG, "passthroughToTv not in passthrough audio format.");
+            return false;
+        }
+
+        // mHdmiCecSink true => mHdmiPlaybackClient != null && playback cec enalbed && tv cec enabled
+        if (mHdmiCecSink
+                && mHdmiCecVolumeControlEnabled) {
+            int keyCode = KeyEvent.KEYCODE_UNKNOWN;
+            if (direction == 0) {
+                direction = getDirection(newIndex, oldIndex, mStreamStates[streamType].getMaxIndex(),
+                                                        mStreamStates[streamType].getMinIndex());
+            }
+            switch (direction) {
+                case AudioManager.ADJUST_RAISE:
+                    keyCode = KeyEvent.KEYCODE_VOLUME_UP;
+                    break;
+                case AudioManager.ADJUST_LOWER:
+                    keyCode = KeyEvent.KEYCODE_VOLUME_DOWN;
+                    break;
+                case AudioManager.ADJUST_MUTE:
+                case AudioManager.ADJUST_TOGGLE_MUTE:
+                    keyCode = KeyEvent.KEYCODE_VOLUME_MUTE;
+                    break;
+                default:
+                    break;
+            }
+            Slog.d(TAG, "passthroughToTv send direction=" + direction + " key=" + keyCode);
+            if (keyCode != KeyEvent.KEYCODE_UNKNOWN) {
+                final long ident = Binder.clearCallingIdentity();
+                try {
+                    final long time = java.lang.System.currentTimeMillis();
+                    switch (keyEventMode) {
+                        case VOL_ADJUST_NORMAL:
+                            mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
+                            mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
+                            break;
+                        case VOL_ADJUST_START:
+                            mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
+                            break;
+                        case VOL_ADJUST_END:
+                            mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
+                            break;
+                        default:
+                            Log.e(TAG, "Invalid keyEventMode " + keyEventMode);
+                    }
+                } finally {
+                    Binder.restoreCallingIdentity(ident);
+                }
+            }
+
+            // show a hint to help the user switch to tv's remote in case tv does not
+            // support volume change even it receives the cec volume key events.
+            showPassthroughToast();
+            return true;
+        }
+        Slog.d(TAG, "passthroughToTv cec disabled or tv no suport cec!");
+        // show a warning to help the user switch to tv's remote when no key events is sent.
+        showPassthroughWarning();
+        return false;
+    }
+
+    private void showPassthroughToast() {
+        boolean showForEveryBoot  = SystemProperties.getBoolean(PROP_PASSTHOURGH_TOAST, true);
+        if (showForEveryBoot) {
+            Slog.d(TAG, "show passthrough hint for the first time");
+            showPassthroughWarning();
+            SystemProperties.set(PROP_PASSTHOURGH_TOAST, "false");
+        }
+    }
+
+    private void showPassthroughWarning() {
+        if (mShowingPassthroughHint) {
+            Slog.d(TAG, "on need to show other passthrough hint");
+            return;
+        }
+        mShowingPassthroughHint = true;
+        mHandler.post(()->{
+            Toast toast = Toast.makeText(mContext, com.android.internal.R.string.volume_passthrough_hint, Toast.LENGTH_LONG);
+            toast.addCallback(new Toast.Callback() {
+                public void onToastHidden() {
+                    mShowingPassthroughHint = false;
+                }
+            });
+            toast.show();
+        });
+    }
+
     private MyHdmiControlStatusChangeListenerCallback mHdmiControlStatusChangeListenerCallback =
             new MyHdmiControlStatusChangeListenerCallback();
 
     private MyHdmiCecVolumeControlFeatureListener mMyHdmiCecVolumeControlFeatureListener =
             new MyHdmiCecVolumeControlFeatureListener();
 
+    private MyDisplayStatusCallback mHdmiDisplayStatusCallback = new MyDisplayStatusCallback();
+
     @Override
     public int setHdmiSystemAudioSupported(boolean on) {
         int device = AudioSystem.DEVICE_NONE;
@@ -7570,6 +7678,7 @@ public class AudioService extends IAudioService.Stub
         pw.print("  mIsSingleVolume="); pw.println(mIsSingleVolume);
         pw.print("  mUseFixedVolume="); pw.println(mUseFixedVolume);
         pw.print("  mFixedVolumeDevices="); pw.println(dumpDeviceTypes(mFixedVolumeDevices));
+        pw.print("  mFullVolumeDevices="); pw.println(dumpDeviceTypes(mFullVolumeDevices));
         pw.print("  mExtVolumeController="); pw.println(mExtVolumeController);
         pw.print("  mHdmiCecSink="); pw.println(mHdmiCecSink);
         pw.print("  mHdmiAudioSystemClient="); pw.println(mHdmiAudioSystemClient);
@@ -7577,6 +7686,9 @@ public class AudioService extends IAudioService.Stub
         pw.print("  mHdmiTvClient="); pw.println(mHdmiTvClient);
         pw.print("  mHdmiSystemAudioSupported="); pw.println(mHdmiSystemAudioSupported);
         pw.print("  mHdmiCecVolumeControlEnabled="); pw.println(mHdmiCecVolumeControlEnabled);
+        pw.print("  mVolumePassthroughEnabled="); pw.println(mVolumePassthroughEnabled);
+        pw.print("  mSupportDolbyMS12="); pw.println(mSupportDolbyMS12);
+        pw.print("  mInVolumePassthrough="); pw.println(mInVolumePassthrough);
         pw.print("  mIsCallScreeningModeSupported="); pw.println(mIsCallScreeningModeSupported);
         pw.print("  mic mute FromSwitch=" + mMicMuteFromSwitch
                         + " FromRestrictions=" + mMicMuteFromRestrictions
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecMessage.java b/services/core/java/com/android/server/hdmi/HdmiCecMessage.java
index ff7da11340eb..595fa83c946d 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecMessage.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecMessage.java
@@ -18,6 +18,8 @@ package com.android.server.hdmi;
 
 import android.annotation.Nullable;
 
+import android.os.Build;
+
 import libcore.util.EmptyArray;
 
 import java.util.Arrays;
@@ -276,6 +278,9 @@ public final class HdmiCecMessage {
     }
 
     private static boolean filterMessageParameters(int opcode) {
+        if (Build.IS_DEBUGGABLE) {
+            return false;
+        }
         switch (opcode) {
             case Constants.MESSAGE_USER_CONTROL_PRESSED:
             case Constants.MESSAGE_USER_CONTROL_RELEASED:
-- 
2.26.1

